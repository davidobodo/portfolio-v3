---
title: Test Coverage
description: How can you know if the tests you have written are enough ?
longDescription: It's a huge milestone to write tests for your application, but then if your tests do not cover the necessary parts of your application then writing the test was simply a waste. In this article we see how we can make use of "jest's coverage" feature to help know how much of our application is being covered by our tests
date: "2022-12-10"
banner: /images/posts/test-coverage/banner.png
bannerAlt: test-coverage
tags:
 - NextJs
 - React Testing Library
 - Jest
url: /blog/test-coverage
readingTime: 4 mins
---

import Image from "next/image";
import { CodeTitle, Center } from "#/components";

<Center>TABLE OF CONTENT</Center>

---

1. [What we need](react-query-data-transformations)
2. [Setting the coverage option](react-query-data-transformations)
3. [Viewing/Analyzing the coverage data](react-query-render-optimizations)
4. [Deciding where to collect coverage from](status-checks-in-react-query)
5. [Improving the firmness of our application using coverage threshold](testing-react-query)

---

### What we need

The purpose of writing tests is to ensure that our application is functioning exactly how we want it to without any errors.

However, after doing so, how can we know if the amount of tests we have written are even enough to cover all important places of our application ?
Say hello to `Jest "collect coverage"`.

With the collect coverage option we can easily know exactly how much of our code has been tested and how much of our code is left to test. Without further ado, let's get into it.

### Setting the coverage option

Open you `jest.config` file and add the collectCoverage option into the file. Your file should now look like this:

<CodeTitle>jest.config.ts</CodeTitle>

```tsx[class="line-numbers"][data-line="11"]
import nextJest from "next/jest";

const createJestConfig = nextJest({
	dir: "./",
});

const customJestConfig = {
	setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],
	testEnvironment: "jest-environment-jsdom",
	verbose: true,
	collectCoverage: true,
};

export default createJestConfig(customJestConfig);
```

With the coverage option set, make sure you restart your terminal. After running the test command again you should see a table like this generated in your console:

{/* <img src="/images/posts/test-coverage/one.png" /> */}

Sweet right ðŸ˜…?

### Viewing/Analyzing the coverage data

That's not all, If you look at the root folder of your application, you would see that a folder named `coverage` has been created for you.

Go into the folder, then into `icov-report` folder, inside which open the `index.html` file in the browser
When you open the `index.html` file in the browser you would see a more beautiful graphical display like this:

{/* <img src="/images/posts/test-coverage/two.png" /> */}

{/* <img src="/images/posts/test-coverage/three.png" /> */}

It lists all the "main" folders being run in your application code and gives information about the code in it.

Let's move into pages since that is our first point of concern
You can see both pages of our application being listed. You would notice that right our table has a header split into basically five columns:
{/* <img src="/images/posts/test-coverage/four.png" /> */}

1. File - The file who has the information we want to display
2. Statements - If all possible executable statements in your code are covered in your tests
3. Branches - If all possible branches (e.g if else statement) in your code are covered in your tests
4. Functions - If all the functions present in your code are covered in your tests
5. Lines - More or less just like "statements"

Since our `index.tsx` is our main home feed page let's go into it. But before going intot it let's take note of our scores i.e

- Statement = 91.04%
- Branches = 90.9%
- Functions = 100%
- Lines = 90.76%

{/* <img src="/images/posts/test-coverage/five.png" /> */}
Now if we open our index.tsx file we should.
Straight up we can see the reason why the scores for our index file is not 100%. The "red" highlighting is showing us, places of our code that were never tested. With this information, we know that we need to write tests for when our network request fails and even also to write test when a user tries to create a post and there is no text in the inputValue

You can see that there is no other easy way we would have been able to check for this, but collecting coverage using jest helps us straight away.

### Deciding where to collect coverage from

By default "jest" tries to collect coverage from all "functioning" files in our application, but if you want to you can specify a `collectCoverageFrom` key in our "jest.config".

In there you can either specify files or folders you want to collect coverage from or you don't want to collect coverage from

<CodeTitle>jest.config.ts</CodeTitle>

```tsx[class="line-numbers"][data-line="12-20"]
import nextJest from "next/jest";

const createJestConfig = nextJest({
	dir: "./",
});

const customJestConfig = {
	setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],
	testEnvironment: "jest-environment-jsdom",
	verbose: true,
	collectCoverage: true,
	collectCoverageFrom: [
		//Cover these files
		"pages/**/*.{js,jsx,ts,tsx}",
		//Dont cover these files
		"!**/node_modules/**",
		"!pages/_app.js",
		"!pages/api/**/*.{js,jsx,ts,tsx}",
	],
};

export default createJestConfig(customJestConfig);
```

### Improving the firmness of our application using coverage threshold

If we are being realistic, most times people do not have the time to write code for every test case such that you have a 100% on the four parameters (i.e statement, branches, functions and lines) that coverage covers.

However with the concept of setting a threshold you can set a comfortable boundary. You can set a threshold for the entire application or simply for specific files.

Setting a threshold for the entire application looks something like this. Open `jest.config`:

<CodeTitle>jest.config.ts</CodeTitle>

```tsx[class="line-numbers"][data-line="20-27"]
import nextJest from "next/jest";

const createJestConfig = nextJest({
	dir: "./",
});

const customJestConfig = {
	setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],
	testEnvironment: "jest-environment-jsdom",
	verbose: true,
	collectCoverage: true,
		collectCoverageFrom: [
		//Cover these files
		"pages/**/*.{js,jsx,ts,tsx}",
		//Dont cover these files
		"!**/node_modules/**",
		"!pages/_app.js",
		"!pages/api/**/*.{js,jsx,ts,tsx}",
	],
	coverageThreshold: {
		global: {
			lines: 80,
			functions: 80,
			branches: 80,
			statements: 80,
		},
	},
};

export default createJestConfig(customJestConfig);
```

We have specified global and set 80 percent as the threshold that we want for our various parameters. Now in our application, anytime our tests run and this threshold is not reached, we would see some sort of notification message in the console.

However the purpose of setting threshold is not mainly for seeing a message in our console, but we can tie this up to our production build such that if our threshold is not met the build fails. This really makes up to be sure that at least the available tests in our application are enough to our standard.

Thank you for reading...
